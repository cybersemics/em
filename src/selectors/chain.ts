import { getContextsSortedAndRanked } from '../selectors'
import { head, pathToContext, splice } from '../util'
import { Context, Path } from '../types'
import { State } from '../util/initialState'

/** Return true if superContext includes subContext. */
const isContextIncludes = (superContext: Context, subContext: Context): boolean => {
  const superAsString = superContext.join('/')
  const subAsString = subContext.join('/')
  return superAsString.includes(subAsString)
}

/** Merges thoughts into a context chain, removing the overlapping head. */
// use autogenerated rank of context
// if there is no/empty context chain, return thoughtsRanked as-is
const chain = (state: State, contextChain: Path[], path: Path, showContexts?: boolean) => {
  // showContexts && console.log('contextChain: ', contextChain)
  // showContexts && console.log('path: ', path)
  const pathAsContext = pathToContext(path)
  // showContexts && console.log('pathToContext: ', pathAsContext)

  if (!contextChain || contextChain.length === 0) return path

  // get the head thought in the last segment of the contextChain
  const pivot = head(contextChain[contextChain.length - 1])
  const i = path.findIndex(child => child.value === pivot.value)
  // TODO: This should never happen, but the Subthoughts test causes i === -1
  // if (i === -1) {
  //   console.warn('chain: contextChain pivot child not found in path',pivot, path)
  //   console.warn('path', pathToContext(path))
  //   console.warn('contextChain', contextChain)
  //   console.warn('pivot', pivot)
  // }

  const append = path.slice(i - 1)
  const contexts = getContextsSortedAndRanked(state, pivot.value)
  // showContexts && console.log('append: ', append)
  // showContexts && console.log('contexts: ', contexts)
  const appendedThoughtInContext = showContexts ? contexts.find(({ context }) => isContextIncludes(pathAsContext, context))
    : contexts.find(child => head(child.context) === append[0].value)
  // showContexts && console.log('appendedThoughtInContext: ', appendedThoughtInContext)
  // keep the first segment intact
  // then remove the overlapping head of each one after
  return contextChain
    .concat([
      appendedThoughtInContext
        ? [{ value: append[0].value, rank: appendedThoughtInContext.rank }].concat(append.slice(1))
        : append
    ])
    .map((thoughts, i) => i > 0 ? splice(thoughts, 1, 1) : thoughts)
    .flat()
}

export default chain
